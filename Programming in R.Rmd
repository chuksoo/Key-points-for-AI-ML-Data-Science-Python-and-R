---
title: "Cheatsheet for Programming in R"
output: html_notebook
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Basic Data Structures in R
### R vectors

A vector is a data structure that can hold multiple objects of the same data type. For example, `c(45, 25, 89, 10)` creates a numerical vector. To access elements, use the `[ ]` brackets with indexing starting from 1.

```{r}
my_string_vector <- c("this", "is", "an", "example", "vector")
my_string_vector[3] # returns "an"
 
my_boolean_vector <- c(TRUE, FALSE, FALSE)
my_numerical_vector <- c(0.4, 0.9, 1, 0.45, 1.2, 0.33)
 
# R will force the same type even if you input different types to c()
my_vector <- c("word", 45, 12, FALSE)
# result: a vector of strings "word" "45" "12" "FALSE"
```

### R Lists

In R, a list can store a variety of data types and data structures in a single variable. This means a list can hold individual strings and numbers, but also vectors and lists.

To access a single element, use `[[ ]]` double brackets. A list is useful for organization because you can name the elements inside it and select them using $

```{r}
my_list <- list("Elephant", FALSE, 900, 80.3, list("pencil", "pens"))
my_list[[4]] # returns 80.3
 
my_longer_list <- list(misc = my_list, notes = c("g", "b", "d", "g"))
 
my_longer_list[[1]]
# returns the contents of my_list
my_longer_list$misc
# returns the contents of my_list
my_longer_list$notes
# returns "g" "b" "d" "g"
```
### R Matrices
To create one, use the `matrix()` function with a vector representing the data (R will interpret whether it is repeating or non-repeating), nrow equal to the number of rows, and ncol equal to the number of columns.

To access a single element inside a matrix called ex_matrix, you can look up the item in the rth row and the cth column like so: `ex_matrix[r, ]`.

To access the entire rth row, you can refer to it like so: `ex_matrix[r, c]`. To access the cth column, use `ex_matrix[ , c]`.

```{r}
# will create a 3-by-3 matrix with the vectors being filled column-wise (default)
my_matrix <- matrix(c("a", "b", "e", "k", "e", "w", "g", "x", "t"), nrow = 3, ncol = 3)
# result:
# "a" "k" "g"
# "b" "e" "x"
# "e" "w" "t"
single_element <- my_matrix[1, 3]
# returns "g"
 
second_row <- my_matrix[2,]
# returns: "b" "e" "x"
second_col <- my_matrix[,2]
# returns: "k" "e" "w"

```

### R Control Flow
Control flow involves the program deciding which code to execute. The decision-making is established through conditional statements, i.e. if, else if, and else. Each condition should compute to a logical TRUE or FALSE. You can use comparison operators like !, & and | to combine logical values.

```{r, eval=FALSE}
if (condition_to_check) {
   # execute code and don't check any more conditions
} else if (other_condition_to_check & and_this_condition_to_check) {
   # execute code only if both are true and don't check any more conditions
} else if (either_this_condition | or_this_condition ) {
   # execute code if either condition is true and don't go to else
} else {
   # the default code if none of the conditions above are true
}
```

### Loops in R
```{r, eval=FALSE}
# how to define a for loop
for (loop_variable in sequence) {
    # code to repeat
}
 
# how to define a while loop
while (condition_to_check_every_iteration) {
    # code to repeat
}
```

### Functions in R
To apply a function onto all the elements in a data structure, we can use one of the apply functions with that function’s name.

 - `apply()` is used on a two-dimensional data structure, and margin value indicates either row or column.
 - `sapply()` is used on any data structure and returns a vector or matrix depending on the number of dimensions.
 - `lapply()` is used on any data structure and always returns a list.

```{r, eval=FALSE}
# the function constructor
my_function <- function(){}

# define a function
function_name <- function(parameter_1, parameter_2, ....) {
   # do something with parameter_1 and parameter_2
   return(some_value)
}

apply(data_structure, margin_value, function_name)
a_vector_or_matrix <- sapply(data structure, function_name)
a_list <- lapply(data_structure, function_name)
```

#### Sample with replacement
```{r}
sample(x = 1:6, size = 2, replace = TRUE)
```
### Reading and Saving Data as csv's
```{r, eval=FALSE}
# reading csv
file_name <- read_csv('file_name.csv')

# writing file to csv
write.csv(file_name, file = "new_file_name.csv", row.names = FALSE)

```


## Statistics in R

```{r, eval=FALSE}
# statistics for data, x
x_mean <- mean(x)          # mean
x_median <- median(x)      # median
x_mode <- Mode(x)          # mode
x_variance <- variance(x)  # variance
x_sd <- sd(x)              # standard deviation
# variance with function
variance <- function(x) mean((x-mean(x))^2)

# Quartiles in R
Quartiles splits the data into four groups of equal size. Those values are called the first quartile (q1), the second quartile (q2), and the third quartile (q3)

q1 <- quantile(df, 0.25)   # first quartile
q2 <- quantile(df, 0.5)    # second quartile or median
q3 <- quantile(df, 0.75)   # third quartile
iqr = q3 - q1 = IQR(df)    # interquartile range or 

# Quantiles
Quantiles are the set of values/points that divides the dataset into groups of equal size.
percentile <- quantile(df, percent)
tenth_percentile <- quantile(df, 0.10) # this is the tenth percentile

# define quartiles and deciles here:
quartiles <- quantile(df, c(0.25, 0.5, 0.75)) # 4-quantiles
deciles <- quantile(df, c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9)) # also called percentiles

# Hypothesis Test Errors
Type I Errors occur when a hypothesis test finds a correlation between things that are not related, and Type II Errors occur when a hypothesis test fails to find a correlation between things that are actually related

Type I errors, also known as false positives, is the error of rejecting a null hypothesis when it is actually true. This can be viewed as a miss being registered as a hit. The acceptable rate of this type of error is called significance level and is usually set to be 0.05 (5%) or 0.01 (1%).

Type II errors, also known as false negatives, is the error of not rejecting a null hypothesis when the alternative hypothesis is the true. This can be viewed as a hit being registered as a miss.

# One Sample T-Test
results <- t.test(sample_distribution, mu = expected_mean)

# Two Sample T-Test, as shown below:
results <- t.test(distribution_1, distribution_2)

# Probability of error for multiple T-Tests:
prob_error <- (1-(0.95**number_of_t_tests))

To perform an ANOVA on a data frame `df` with the different samples in column `groups` and values in column `vals`:
# Analysis of Variance
results <- aov(vals ~ group, data = df)

# p-value of the ANOVA:
summary(results)
```


## Data Wranging in R
```{r, eval=FALSE}
# Inspect data
head(df)
summary(df)

# View number of row
print(nrow(df))

# Show column names
print(colnames(df)) | print(names(df))

# Extract single column from a dataframe
To get a single column from a DataFrame, you can use any of this syntax:
one_column <- data$column_name

single_column <- data_frame_name %>%
  select(column_name)

To return a vector instead of a dataframe object, use `pull()`
single_column <- data_frame_name %>%
  pull(column_name)

# Filter a dataset and convert data to vector
new_data_frame <- data_frame %>%
  filter(column_name <= mean(column_name)) %>%
  pull(another_column_name)

# Select columns
select() returns a new data frame containing only the desired columns. When using the pipe, you can read the code as: from the customers table, select() the age and gender columns. 

customers %>%
  select(age, gender)

# Excluding columns
To exclude the columns you do not need:

customers %>%
  select(-name, -phone)

# Filter rows with logic
Let’s say you want to find all orders made by customers with the first name 'Joyce'.

orders %>%
  filter(first_name == 'Joyce') # give a new data frame containing only the rows where first_name == 'Joyce' 

orders %>%
  filter(shoe_material == 'faux-leather', price > 25)

orders %>%
  filter(shoe_type == 'clogs' | price < 20) # "|" represents 'OR'

orders %>%
  filter(!(shoe_color == red))

# Arranging Rows
To arrange the customers in ascending order by name:

customers %>%
  arrange(name)

To arrange the customers in descending order by age:

customers %>%
  arrange(desc(age))

To `arrange()` a data frame df by `col_c` in descending order after it has undergone a filter() according to condition_a and condition_b after multiple columns have been selected:

result <- df %>%
  select(-col_1, -col_2) %>%
  filter(condition_a, condition_b) %>%
  arrange(desc(col_c))

# Adding a Column
You can add a new column to the data frame using the mutate() function.
df %>%
  mutate(profit = price - cost_to_manufacture,
         in_stock = TRUE)
```

```{r}
# Examples of Data Wrangling with R
# load libraries
library(readr)
library(dplyr)
library(tidyr)

# create dataframe
df <- data.frame(
	Semester = c("Fall 2016", "Fall 2016", "Spring 2016", "Fall 2017", "Fall 2016"),
	Class = c("Algorithms_101", "Machine_Learning", "Test_Driven_Development", "UI_Design", "Machine_Learning"),
	Test_grade = c(98, 78, 82, 91, 78),
	Year_occurred = c("2008AD", "1959AD", "1945AD", "1184BC", "1959AD"),
	Exam_score = c("89%", "83%", "91%", "95%", "83%")
	)
df
```
```{r}
# To remove any duplicate rows from a dataframe
no_duplicate_df <- df %>% 
  distinct()
no_duplicate_df
```
```{r}
#  `Separate` out season and year in the dataframe
df %>% 
  separate(Semester, c('Season', 'Year'), ' ')

```

```{r}
# Add new columns to a data frame and drop existing columns using transmute()
require(stringr)
no_duplicate_df %>% transmute(
		year = str_sub(Year_occurred, 1, 4), 
		suffix = str_sub(Year_occurred, 5, 6)
	)
```

```{r}
# Select columns, filter and arrange rows
no_duplicate_df %>%
	select(-Year_occurred, -Exam_score) %>%
		filter(Semester == 'Fall 2016' | Semester == 'Fall 2017', Test_grade >= 70) %>%
		arrange(desc(Test_grade))

```
```{r}
# Add new columns to a data frame using mutate()
df <- df %>%
	mutate(
		Adjusted_score = Test_grade * (mean(Test_grade)/ 100)
		) 
df
```
```{r, eval=FALSE}
# Remove the %s from a set of column, you can use mutate() and gsub() with the below syntax:
df %>%
  mutate(column_name_1=gsub('\\%','',column_name_1),
         column_name_2=gsub('\\%','',column_name_2),
         column_name_3=gsub('\\%','',column_name_3))

```

```{r}
df <- df %>% 
  mutate(Exam_score = gsub('\\%', '', Exam_score))
```


```{r, eval=FALSE}
# Change the column names of a data frame using rename()
df %>%
  rename(semester = Semester,
         class = Class,
         score = Test_grade,
         year = Year_occurred,
         grade = Exam_score,
         finals = Adjusted_score
		 )
```

```{r}
# check column names
original_col_names <- colnames(df)
original_col_names
```


```{r, eval=FALSE}
tryCatch(print(paste("The second quartile of dataset two is",dataset_two_q2)), error=function(e) {print("You haven't defined dataset_two_q2")})
```


